// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ImuEncode.proto

#ifndef PROTOBUF_INCLUDED_ImuEncode_2eproto
#define PROTOBUF_INCLUDED_ImuEncode_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_ImuEncode_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_ImuEncode_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[8]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_ImuEncode_2eproto();
namespace ImuTutorial {
class Datalength;
class DatalengthDefaultTypeInternal;
extern DatalengthDefaultTypeInternal _Datalength_default_instance_;
class ImuSignal;
class ImuSignalDefaultTypeInternal;
extern ImuSignalDefaultTypeInternal _ImuSignal_default_instance_;
class ImuSignalDataset;
class ImuSignalDatasetDefaultTypeInternal;
extern ImuSignalDatasetDefaultTypeInternal _ImuSignalDataset_default_instance_;
class Signal;
class SignalDefaultTypeInternal;
extern SignalDefaultTypeInternal _Signal_default_instance_;
class Signal_Acc;
class Signal_AccDefaultTypeInternal;
extern Signal_AccDefaultTypeInternal _Signal_Acc_default_instance_;
class Signal_Angle;
class Signal_AngleDefaultTypeInternal;
extern Signal_AngleDefaultTypeInternal _Signal_Angle_default_instance_;
class Signal_AngleRate;
class Signal_AngleRateDefaultTypeInternal;
extern Signal_AngleRateDefaultTypeInternal _Signal_AngleRate_default_instance_;
class Signal_Quaternion;
class Signal_QuaternionDefaultTypeInternal;
extern Signal_QuaternionDefaultTypeInternal _Signal_Quaternion_default_instance_;
}  // namespace ImuTutorial
namespace google {
namespace protobuf {
template<> ::ImuTutorial::Datalength* Arena::CreateMaybeMessage<::ImuTutorial::Datalength>(Arena*);
template<> ::ImuTutorial::ImuSignal* Arena::CreateMaybeMessage<::ImuTutorial::ImuSignal>(Arena*);
template<> ::ImuTutorial::ImuSignalDataset* Arena::CreateMaybeMessage<::ImuTutorial::ImuSignalDataset>(Arena*);
template<> ::ImuTutorial::Signal* Arena::CreateMaybeMessage<::ImuTutorial::Signal>(Arena*);
template<> ::ImuTutorial::Signal_Acc* Arena::CreateMaybeMessage<::ImuTutorial::Signal_Acc>(Arena*);
template<> ::ImuTutorial::Signal_Angle* Arena::CreateMaybeMessage<::ImuTutorial::Signal_Angle>(Arena*);
template<> ::ImuTutorial::Signal_AngleRate* Arena::CreateMaybeMessage<::ImuTutorial::Signal_AngleRate>(Arena*);
template<> ::ImuTutorial::Signal_Quaternion* Arena::CreateMaybeMessage<::ImuTutorial::Signal_Quaternion>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace ImuTutorial {

enum Signal_Leg {
  Signal_Leg_RT = 0,
  Signal_Leg_LT = 1
};
bool Signal_Leg_IsValid(int value);
const Signal_Leg Signal_Leg_Leg_MIN = Signal_Leg_RT;
const Signal_Leg Signal_Leg_Leg_MAX = Signal_Leg_LT;
const int Signal_Leg_Leg_ARRAYSIZE = Signal_Leg_Leg_MAX + 1;

const ::google::protobuf::EnumDescriptor* Signal_Leg_descriptor();
inline const ::std::string& Signal_Leg_Name(Signal_Leg value) {
  return ::google::protobuf::internal::NameOfEnum(
    Signal_Leg_descriptor(), value);
}
inline bool Signal_Leg_Parse(
    const ::std::string& name, Signal_Leg* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Signal_Leg>(
    Signal_Leg_descriptor(), name, value);
}
enum Signal_LegPosition {
  Signal_LegPosition_Foot = 0,
  Signal_LegPosition_Thigh = 1
};
bool Signal_LegPosition_IsValid(int value);
const Signal_LegPosition Signal_LegPosition_LegPosition_MIN = Signal_LegPosition_Foot;
const Signal_LegPosition Signal_LegPosition_LegPosition_MAX = Signal_LegPosition_Thigh;
const int Signal_LegPosition_LegPosition_ARRAYSIZE = Signal_LegPosition_LegPosition_MAX + 1;

const ::google::protobuf::EnumDescriptor* Signal_LegPosition_descriptor();
inline const ::std::string& Signal_LegPosition_Name(Signal_LegPosition value) {
  return ::google::protobuf::internal::NameOfEnum(
    Signal_LegPosition_descriptor(), value);
}
inline bool Signal_LegPosition_Parse(
    const ::std::string& name, Signal_LegPosition* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Signal_LegPosition>(
    Signal_LegPosition_descriptor(), name, value);
}
// ===================================================================

class Signal_Acc :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ImuTutorial.Signal.Acc) */ {
 public:
  Signal_Acc();
  virtual ~Signal_Acc();

  Signal_Acc(const Signal_Acc& from);

  inline Signal_Acc& operator=(const Signal_Acc& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Signal_Acc(Signal_Acc&& from) noexcept
    : Signal_Acc() {
    *this = ::std::move(from);
  }

  inline Signal_Acc& operator=(Signal_Acc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Signal_Acc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signal_Acc* internal_default_instance() {
    return reinterpret_cast<const Signal_Acc*>(
               &_Signal_Acc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Signal_Acc* other);
  friend void swap(Signal_Acc& a, Signal_Acc& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Signal_Acc* New() const final {
    return CreateMaybeMessage<Signal_Acc>(nullptr);
  }

  Signal_Acc* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Signal_Acc>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Signal_Acc& from);
  void MergeFrom(const Signal_Acc& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signal_Acc* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float AccX = 1;
  bool has_accx() const;
  void clear_accx();
  static const int kAccXFieldNumber = 1;
  float accx() const;
  void set_accx(float value);

  // required float AccY = 2;
  bool has_accy() const;
  void clear_accy();
  static const int kAccYFieldNumber = 2;
  float accy() const;
  void set_accy(float value);

  // required float AccZ = 3;
  bool has_accz() const;
  void clear_accz();
  static const int kAccZFieldNumber = 3;
  float accz() const;
  void set_accz(float value);

  // @@protoc_insertion_point(class_scope:ImuTutorial.Signal.Acc)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float accx_;
  float accy_;
  float accz_;
  friend struct ::TableStruct_ImuEncode_2eproto;
};
// -------------------------------------------------------------------

class Signal_Angle :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ImuTutorial.Signal.Angle) */ {
 public:
  Signal_Angle();
  virtual ~Signal_Angle();

  Signal_Angle(const Signal_Angle& from);

  inline Signal_Angle& operator=(const Signal_Angle& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Signal_Angle(Signal_Angle&& from) noexcept
    : Signal_Angle() {
    *this = ::std::move(from);
  }

  inline Signal_Angle& operator=(Signal_Angle&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Signal_Angle& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signal_Angle* internal_default_instance() {
    return reinterpret_cast<const Signal_Angle*>(
               &_Signal_Angle_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Signal_Angle* other);
  friend void swap(Signal_Angle& a, Signal_Angle& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Signal_Angle* New() const final {
    return CreateMaybeMessage<Signal_Angle>(nullptr);
  }

  Signal_Angle* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Signal_Angle>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Signal_Angle& from);
  void MergeFrom(const Signal_Angle& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signal_Angle* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float Course = 1;
  bool has_course() const;
  void clear_course();
  static const int kCourseFieldNumber = 1;
  float course() const;
  void set_course(float value);

  // required float Roll = 2;
  bool has_roll() const;
  void clear_roll();
  static const int kRollFieldNumber = 2;
  float roll() const;
  void set_roll(float value);

  // required float Pitch = 3;
  bool has_pitch() const;
  void clear_pitch();
  static const int kPitchFieldNumber = 3;
  float pitch() const;
  void set_pitch(float value);

  // @@protoc_insertion_point(class_scope:ImuTutorial.Signal.Angle)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float course_;
  float roll_;
  float pitch_;
  friend struct ::TableStruct_ImuEncode_2eproto;
};
// -------------------------------------------------------------------

class Signal_AngleRate :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ImuTutorial.Signal.AngleRate) */ {
 public:
  Signal_AngleRate();
  virtual ~Signal_AngleRate();

  Signal_AngleRate(const Signal_AngleRate& from);

  inline Signal_AngleRate& operator=(const Signal_AngleRate& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Signal_AngleRate(Signal_AngleRate&& from) noexcept
    : Signal_AngleRate() {
    *this = ::std::move(from);
  }

  inline Signal_AngleRate& operator=(Signal_AngleRate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Signal_AngleRate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signal_AngleRate* internal_default_instance() {
    return reinterpret_cast<const Signal_AngleRate*>(
               &_Signal_AngleRate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Signal_AngleRate* other);
  friend void swap(Signal_AngleRate& a, Signal_AngleRate& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Signal_AngleRate* New() const final {
    return CreateMaybeMessage<Signal_AngleRate>(nullptr);
  }

  Signal_AngleRate* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Signal_AngleRate>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Signal_AngleRate& from);
  void MergeFrom(const Signal_AngleRate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signal_AngleRate* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float Course = 1;
  bool has_course() const;
  void clear_course();
  static const int kCourseFieldNumber = 1;
  float course() const;
  void set_course(float value);

  // optional float Roll = 2;
  bool has_roll() const;
  void clear_roll();
  static const int kRollFieldNumber = 2;
  float roll() const;
  void set_roll(float value);

  // optional float Pitch = 3;
  bool has_pitch() const;
  void clear_pitch();
  static const int kPitchFieldNumber = 3;
  float pitch() const;
  void set_pitch(float value);

  // @@protoc_insertion_point(class_scope:ImuTutorial.Signal.AngleRate)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float course_;
  float roll_;
  float pitch_;
  friend struct ::TableStruct_ImuEncode_2eproto;
};
// -------------------------------------------------------------------

class Signal_Quaternion :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ImuTutorial.Signal.Quaternion) */ {
 public:
  Signal_Quaternion();
  virtual ~Signal_Quaternion();

  Signal_Quaternion(const Signal_Quaternion& from);

  inline Signal_Quaternion& operator=(const Signal_Quaternion& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Signal_Quaternion(Signal_Quaternion&& from) noexcept
    : Signal_Quaternion() {
    *this = ::std::move(from);
  }

  inline Signal_Quaternion& operator=(Signal_Quaternion&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Signal_Quaternion& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signal_Quaternion* internal_default_instance() {
    return reinterpret_cast<const Signal_Quaternion*>(
               &_Signal_Quaternion_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Signal_Quaternion* other);
  friend void swap(Signal_Quaternion& a, Signal_Quaternion& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Signal_Quaternion* New() const final {
    return CreateMaybeMessage<Signal_Quaternion>(nullptr);
  }

  Signal_Quaternion* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Signal_Quaternion>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Signal_Quaternion& from);
  void MergeFrom(const Signal_Quaternion& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signal_Quaternion* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float v = 1;
  bool has_v() const;
  void clear_v();
  static const int kVFieldNumber = 1;
  float v() const;
  void set_v(float value);

  // required float x = 2;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 2;
  float x() const;
  void set_x(float value);

  // required float y = 3;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 3;
  float y() const;
  void set_y(float value);

  // required float z = 4;
  bool has_z() const;
  void clear_z();
  static const int kZFieldNumber = 4;
  float z() const;
  void set_z(float value);

  // @@protoc_insertion_point(class_scope:ImuTutorial.Signal.Quaternion)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float v_;
  float x_;
  float y_;
  float z_;
  friend struct ::TableStruct_ImuEncode_2eproto;
};
// -------------------------------------------------------------------

class Signal :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ImuTutorial.Signal) */ {
 public:
  Signal();
  virtual ~Signal();

  Signal(const Signal& from);

  inline Signal& operator=(const Signal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Signal(Signal&& from) noexcept
    : Signal() {
    *this = ::std::move(from);
  }

  inline Signal& operator=(Signal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Signal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Signal* internal_default_instance() {
    return reinterpret_cast<const Signal*>(
               &_Signal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Signal* other);
  friend void swap(Signal& a, Signal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Signal* New() const final {
    return CreateMaybeMessage<Signal>(nullptr);
  }

  Signal* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Signal>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Signal& from);
  void MergeFrom(const Signal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Signal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Signal_Acc Acc;
  typedef Signal_Angle Angle;
  typedef Signal_AngleRate AngleRate;
  typedef Signal_Quaternion Quaternion;

  typedef Signal_Leg Leg;
  static const Leg RT =
    Signal_Leg_RT;
  static const Leg LT =
    Signal_Leg_LT;
  static inline bool Leg_IsValid(int value) {
    return Signal_Leg_IsValid(value);
  }
  static const Leg Leg_MIN =
    Signal_Leg_Leg_MIN;
  static const Leg Leg_MAX =
    Signal_Leg_Leg_MAX;
  static const int Leg_ARRAYSIZE =
    Signal_Leg_Leg_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Leg_descriptor() {
    return Signal_Leg_descriptor();
  }
  static inline const ::std::string& Leg_Name(Leg value) {
    return Signal_Leg_Name(value);
  }
  static inline bool Leg_Parse(const ::std::string& name,
      Leg* value) {
    return Signal_Leg_Parse(name, value);
  }

  typedef Signal_LegPosition LegPosition;
  static const LegPosition Foot =
    Signal_LegPosition_Foot;
  static const LegPosition Thigh =
    Signal_LegPosition_Thigh;
  static inline bool LegPosition_IsValid(int value) {
    return Signal_LegPosition_IsValid(value);
  }
  static const LegPosition LegPosition_MIN =
    Signal_LegPosition_LegPosition_MIN;
  static const LegPosition LegPosition_MAX =
    Signal_LegPosition_LegPosition_MAX;
  static const int LegPosition_ARRAYSIZE =
    Signal_LegPosition_LegPosition_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LegPosition_descriptor() {
    return Signal_LegPosition_descriptor();
  }
  static inline const ::std::string& LegPosition_Name(LegPosition value) {
    return Signal_LegPosition_Name(value);
  }
  static inline bool LegPosition_Parse(const ::std::string& name,
      LegPosition* value) {
    return Signal_LegPosition_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .ImuTutorial.Signal.Acc acc = 6;
  bool has_acc() const;
  void clear_acc();
  static const int kAccFieldNumber = 6;
  const ::ImuTutorial::Signal_Acc& acc() const;
  ::ImuTutorial::Signal_Acc* release_acc();
  ::ImuTutorial::Signal_Acc* mutable_acc();
  void set_allocated_acc(::ImuTutorial::Signal_Acc* acc);

  // required .ImuTutorial.Signal.Angle angle = 7;
  bool has_angle() const;
  void clear_angle();
  static const int kAngleFieldNumber = 7;
  const ::ImuTutorial::Signal_Angle& angle() const;
  ::ImuTutorial::Signal_Angle* release_angle();
  ::ImuTutorial::Signal_Angle* mutable_angle();
  void set_allocated_angle(::ImuTutorial::Signal_Angle* angle);

  // required .ImuTutorial.Signal.AngleRate anglerate = 8;
  bool has_anglerate() const;
  void clear_anglerate();
  static const int kAnglerateFieldNumber = 8;
  const ::ImuTutorial::Signal_AngleRate& anglerate() const;
  ::ImuTutorial::Signal_AngleRate* release_anglerate();
  ::ImuTutorial::Signal_AngleRate* mutable_anglerate();
  void set_allocated_anglerate(::ImuTutorial::Signal_AngleRate* anglerate);

  // optional .ImuTutorial.Signal.Quaternion quaternion = 9;
  bool has_quaternion() const;
  void clear_quaternion();
  static const int kQuaternionFieldNumber = 9;
  const ::ImuTutorial::Signal_Quaternion& quaternion() const;
  ::ImuTutorial::Signal_Quaternion* release_quaternion();
  ::ImuTutorial::Signal_Quaternion* mutable_quaternion();
  void set_allocated_quaternion(::ImuTutorial::Signal_Quaternion* quaternion);

  // required .ImuTutorial.Signal.Leg leg = 1 [default = RT];
  bool has_leg() const;
  void clear_leg();
  static const int kLegFieldNumber = 1;
  ::ImuTutorial::Signal_Leg leg() const;
  void set_leg(::ImuTutorial::Signal_Leg value);

  // required .ImuTutorial.Signal.LegPosition legposition = 2 [default = Foot];
  bool has_legposition() const;
  void clear_legposition();
  static const int kLegpositionFieldNumber = 2;
  ::ImuTutorial::Signal_LegPosition legposition() const;
  void set_legposition(::ImuTutorial::Signal_LegPosition value);

  // optional int64 time = 4;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 4;
  ::google::protobuf::int64 time() const;
  void set_time(::google::protobuf::int64 value);

  // optional float TimeStamp = 3;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimeStampFieldNumber = 3;
  float timestamp() const;
  void set_timestamp(float value);

  // optional int32 id = 5;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 5;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ImuTutorial.Signal)
 private:
  class HasBitSetters;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::ImuTutorial::Signal_Acc* acc_;
  ::ImuTutorial::Signal_Angle* angle_;
  ::ImuTutorial::Signal_AngleRate* anglerate_;
  ::ImuTutorial::Signal_Quaternion* quaternion_;
  int leg_;
  int legposition_;
  ::google::protobuf::int64 time_;
  float timestamp_;
  ::google::protobuf::int32 id_;
  friend struct ::TableStruct_ImuEncode_2eproto;
};
// -------------------------------------------------------------------

class ImuSignal :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ImuTutorial.ImuSignal) */ {
 public:
  ImuSignal();
  virtual ~ImuSignal();

  ImuSignal(const ImuSignal& from);

  inline ImuSignal& operator=(const ImuSignal& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImuSignal(ImuSignal&& from) noexcept
    : ImuSignal() {
    *this = ::std::move(from);
  }

  inline ImuSignal& operator=(ImuSignal&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ImuSignal& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImuSignal* internal_default_instance() {
    return reinterpret_cast<const ImuSignal*>(
               &_ImuSignal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(ImuSignal* other);
  friend void swap(ImuSignal& a, ImuSignal& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImuSignal* New() const final {
    return CreateMaybeMessage<ImuSignal>(nullptr);
  }

  ImuSignal* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ImuSignal>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ImuSignal& from);
  void MergeFrom(const ImuSignal& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImuSignal* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ImuTutorial.Signal signal = 2;
  int signal_size() const;
  void clear_signal();
  static const int kSignalFieldNumber = 2;
  ::ImuTutorial::Signal* mutable_signal(int index);
  ::google::protobuf::RepeatedPtrField< ::ImuTutorial::Signal >*
      mutable_signal();
  const ::ImuTutorial::Signal& signal(int index) const;
  ::ImuTutorial::Signal* add_signal();
  const ::google::protobuf::RepeatedPtrField< ::ImuTutorial::Signal >&
      signal() const;

  // required uint64 time = 1;
  bool has_time() const;
  void clear_time();
  static const int kTimeFieldNumber = 1;
  ::google::protobuf::uint64 time() const;
  void set_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:ImuTutorial.ImuSignal)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ImuTutorial::Signal > signal_;
  ::google::protobuf::uint64 time_;
  friend struct ::TableStruct_ImuEncode_2eproto;
};
// -------------------------------------------------------------------

class ImuSignalDataset :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ImuTutorial.ImuSignalDataset) */ {
 public:
  ImuSignalDataset();
  virtual ~ImuSignalDataset();

  ImuSignalDataset(const ImuSignalDataset& from);

  inline ImuSignalDataset& operator=(const ImuSignalDataset& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ImuSignalDataset(ImuSignalDataset&& from) noexcept
    : ImuSignalDataset() {
    *this = ::std::move(from);
  }

  inline ImuSignalDataset& operator=(ImuSignalDataset&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ImuSignalDataset& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ImuSignalDataset* internal_default_instance() {
    return reinterpret_cast<const ImuSignalDataset*>(
               &_ImuSignalDataset_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(ImuSignalDataset* other);
  friend void swap(ImuSignalDataset& a, ImuSignalDataset& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ImuSignalDataset* New() const final {
    return CreateMaybeMessage<ImuSignalDataset>(nullptr);
  }

  ImuSignalDataset* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ImuSignalDataset>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ImuSignalDataset& from);
  void MergeFrom(const ImuSignalDataset& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ImuSignalDataset* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .ImuTutorial.ImuSignal imusignal = 1;
  int imusignal_size() const;
  void clear_imusignal();
  static const int kImusignalFieldNumber = 1;
  ::ImuTutorial::ImuSignal* mutable_imusignal(int index);
  ::google::protobuf::RepeatedPtrField< ::ImuTutorial::ImuSignal >*
      mutable_imusignal();
  const ::ImuTutorial::ImuSignal& imusignal(int index) const;
  ::ImuTutorial::ImuSignal* add_imusignal();
  const ::google::protobuf::RepeatedPtrField< ::ImuTutorial::ImuSignal >&
      imusignal() const;

  // @@protoc_insertion_point(class_scope:ImuTutorial.ImuSignalDataset)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::ImuTutorial::ImuSignal > imusignal_;
  friend struct ::TableStruct_ImuEncode_2eproto;
};
// -------------------------------------------------------------------

class Datalength :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:ImuTutorial.Datalength) */ {
 public:
  Datalength();
  virtual ~Datalength();

  Datalength(const Datalength& from);

  inline Datalength& operator=(const Datalength& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Datalength(Datalength&& from) noexcept
    : Datalength() {
    *this = ::std::move(from);
  }

  inline Datalength& operator=(Datalength&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Datalength& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Datalength* internal_default_instance() {
    return reinterpret_cast<const Datalength*>(
               &_Datalength_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Datalength* other);
  friend void swap(Datalength& a, Datalength& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Datalength* New() const final {
    return CreateMaybeMessage<Datalength>(nullptr);
  }

  Datalength* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Datalength>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Datalength& from);
  void MergeFrom(const Datalength& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Datalength* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 length = 1;
  bool has_length() const;
  void clear_length();
  static const int kLengthFieldNumber = 1;
  ::google::protobuf::uint32 length() const;
  void set_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:ImuTutorial.Datalength)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::uint32 length_;
  friend struct ::TableStruct_ImuEncode_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Signal_Acc

// required float AccX = 1;
inline bool Signal_Acc::has_accx() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Signal_Acc::clear_accx() {
  accx_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Signal_Acc::accx() const {
  // @@protoc_insertion_point(field_get:ImuTutorial.Signal.Acc.AccX)
  return accx_;
}
inline void Signal_Acc::set_accx(float value) {
  _has_bits_[0] |= 0x00000001u;
  accx_ = value;
  // @@protoc_insertion_point(field_set:ImuTutorial.Signal.Acc.AccX)
}

// required float AccY = 2;
inline bool Signal_Acc::has_accy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Signal_Acc::clear_accy() {
  accy_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Signal_Acc::accy() const {
  // @@protoc_insertion_point(field_get:ImuTutorial.Signal.Acc.AccY)
  return accy_;
}
inline void Signal_Acc::set_accy(float value) {
  _has_bits_[0] |= 0x00000002u;
  accy_ = value;
  // @@protoc_insertion_point(field_set:ImuTutorial.Signal.Acc.AccY)
}

// required float AccZ = 3;
inline bool Signal_Acc::has_accz() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Signal_Acc::clear_accz() {
  accz_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Signal_Acc::accz() const {
  // @@protoc_insertion_point(field_get:ImuTutorial.Signal.Acc.AccZ)
  return accz_;
}
inline void Signal_Acc::set_accz(float value) {
  _has_bits_[0] |= 0x00000004u;
  accz_ = value;
  // @@protoc_insertion_point(field_set:ImuTutorial.Signal.Acc.AccZ)
}

// -------------------------------------------------------------------

// Signal_Angle

// optional float Course = 1;
inline bool Signal_Angle::has_course() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Signal_Angle::clear_course() {
  course_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Signal_Angle::course() const {
  // @@protoc_insertion_point(field_get:ImuTutorial.Signal.Angle.Course)
  return course_;
}
inline void Signal_Angle::set_course(float value) {
  _has_bits_[0] |= 0x00000001u;
  course_ = value;
  // @@protoc_insertion_point(field_set:ImuTutorial.Signal.Angle.Course)
}

// required float Roll = 2;
inline bool Signal_Angle::has_roll() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Signal_Angle::clear_roll() {
  roll_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Signal_Angle::roll() const {
  // @@protoc_insertion_point(field_get:ImuTutorial.Signal.Angle.Roll)
  return roll_;
}
inline void Signal_Angle::set_roll(float value) {
  _has_bits_[0] |= 0x00000002u;
  roll_ = value;
  // @@protoc_insertion_point(field_set:ImuTutorial.Signal.Angle.Roll)
}

// required float Pitch = 3;
inline bool Signal_Angle::has_pitch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Signal_Angle::clear_pitch() {
  pitch_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Signal_Angle::pitch() const {
  // @@protoc_insertion_point(field_get:ImuTutorial.Signal.Angle.Pitch)
  return pitch_;
}
inline void Signal_Angle::set_pitch(float value) {
  _has_bits_[0] |= 0x00000004u;
  pitch_ = value;
  // @@protoc_insertion_point(field_set:ImuTutorial.Signal.Angle.Pitch)
}

// -------------------------------------------------------------------

// Signal_AngleRate

// required float Course = 1;
inline bool Signal_AngleRate::has_course() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Signal_AngleRate::clear_course() {
  course_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Signal_AngleRate::course() const {
  // @@protoc_insertion_point(field_get:ImuTutorial.Signal.AngleRate.Course)
  return course_;
}
inline void Signal_AngleRate::set_course(float value) {
  _has_bits_[0] |= 0x00000001u;
  course_ = value;
  // @@protoc_insertion_point(field_set:ImuTutorial.Signal.AngleRate.Course)
}

// optional float Roll = 2;
inline bool Signal_AngleRate::has_roll() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Signal_AngleRate::clear_roll() {
  roll_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Signal_AngleRate::roll() const {
  // @@protoc_insertion_point(field_get:ImuTutorial.Signal.AngleRate.Roll)
  return roll_;
}
inline void Signal_AngleRate::set_roll(float value) {
  _has_bits_[0] |= 0x00000002u;
  roll_ = value;
  // @@protoc_insertion_point(field_set:ImuTutorial.Signal.AngleRate.Roll)
}

// optional float Pitch = 3;
inline bool Signal_AngleRate::has_pitch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Signal_AngleRate::clear_pitch() {
  pitch_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Signal_AngleRate::pitch() const {
  // @@protoc_insertion_point(field_get:ImuTutorial.Signal.AngleRate.Pitch)
  return pitch_;
}
inline void Signal_AngleRate::set_pitch(float value) {
  _has_bits_[0] |= 0x00000004u;
  pitch_ = value;
  // @@protoc_insertion_point(field_set:ImuTutorial.Signal.AngleRate.Pitch)
}

// -------------------------------------------------------------------

// Signal_Quaternion

// optional float v = 1;
inline bool Signal_Quaternion::has_v() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Signal_Quaternion::clear_v() {
  v_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float Signal_Quaternion::v() const {
  // @@protoc_insertion_point(field_get:ImuTutorial.Signal.Quaternion.v)
  return v_;
}
inline void Signal_Quaternion::set_v(float value) {
  _has_bits_[0] |= 0x00000001u;
  v_ = value;
  // @@protoc_insertion_point(field_set:ImuTutorial.Signal.Quaternion.v)
}

// required float x = 2;
inline bool Signal_Quaternion::has_x() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Signal_Quaternion::clear_x() {
  x_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline float Signal_Quaternion::x() const {
  // @@protoc_insertion_point(field_get:ImuTutorial.Signal.Quaternion.x)
  return x_;
}
inline void Signal_Quaternion::set_x(float value) {
  _has_bits_[0] |= 0x00000002u;
  x_ = value;
  // @@protoc_insertion_point(field_set:ImuTutorial.Signal.Quaternion.x)
}

// required float y = 3;
inline bool Signal_Quaternion::has_y() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Signal_Quaternion::clear_y() {
  y_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline float Signal_Quaternion::y() const {
  // @@protoc_insertion_point(field_get:ImuTutorial.Signal.Quaternion.y)
  return y_;
}
inline void Signal_Quaternion::set_y(float value) {
  _has_bits_[0] |= 0x00000004u;
  y_ = value;
  // @@protoc_insertion_point(field_set:ImuTutorial.Signal.Quaternion.y)
}

// required float z = 4;
inline bool Signal_Quaternion::has_z() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Signal_Quaternion::clear_z() {
  z_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline float Signal_Quaternion::z() const {
  // @@protoc_insertion_point(field_get:ImuTutorial.Signal.Quaternion.z)
  return z_;
}
inline void Signal_Quaternion::set_z(float value) {
  _has_bits_[0] |= 0x00000008u;
  z_ = value;
  // @@protoc_insertion_point(field_set:ImuTutorial.Signal.Quaternion.z)
}

// -------------------------------------------------------------------

// Signal

// required .ImuTutorial.Signal.Leg leg = 1 [default = RT];
inline bool Signal::has_leg() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Signal::clear_leg() {
  leg_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::ImuTutorial::Signal_Leg Signal::leg() const {
  // @@protoc_insertion_point(field_get:ImuTutorial.Signal.leg)
  return static_cast< ::ImuTutorial::Signal_Leg >(leg_);
}
inline void Signal::set_leg(::ImuTutorial::Signal_Leg value) {
  assert(::ImuTutorial::Signal_Leg_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  leg_ = value;
  // @@protoc_insertion_point(field_set:ImuTutorial.Signal.leg)
}

// required .ImuTutorial.Signal.LegPosition legposition = 2 [default = Foot];
inline bool Signal::has_legposition() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Signal::clear_legposition() {
  legposition_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::ImuTutorial::Signal_LegPosition Signal::legposition() const {
  // @@protoc_insertion_point(field_get:ImuTutorial.Signal.legposition)
  return static_cast< ::ImuTutorial::Signal_LegPosition >(legposition_);
}
inline void Signal::set_legposition(::ImuTutorial::Signal_LegPosition value) {
  assert(::ImuTutorial::Signal_LegPosition_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  legposition_ = value;
  // @@protoc_insertion_point(field_set:ImuTutorial.Signal.legposition)
}

// optional float TimeStamp = 3;
inline bool Signal::has_timestamp() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Signal::clear_timestamp() {
  timestamp_ = 0;
  _has_bits_[0] &= ~0x00000080u;
}
inline float Signal::timestamp() const {
  // @@protoc_insertion_point(field_get:ImuTutorial.Signal.TimeStamp)
  return timestamp_;
}
inline void Signal::set_timestamp(float value) {
  _has_bits_[0] |= 0x00000080u;
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:ImuTutorial.Signal.TimeStamp)
}

// optional int64 time = 4;
inline bool Signal::has_time() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Signal::clear_time() {
  time_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::google::protobuf::int64 Signal::time() const {
  // @@protoc_insertion_point(field_get:ImuTutorial.Signal.time)
  return time_;
}
inline void Signal::set_time(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000040u;
  time_ = value;
  // @@protoc_insertion_point(field_set:ImuTutorial.Signal.time)
}

// optional int32 id = 5;
inline bool Signal::has_id() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Signal::clear_id() {
  id_ = 0;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::google::protobuf::int32 Signal::id() const {
  // @@protoc_insertion_point(field_get:ImuTutorial.Signal.id)
  return id_;
}
inline void Signal::set_id(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000100u;
  id_ = value;
  // @@protoc_insertion_point(field_set:ImuTutorial.Signal.id)
}

// required .ImuTutorial.Signal.Acc acc = 6;
inline bool Signal::has_acc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Signal::clear_acc() {
  if (acc_ != nullptr) acc_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::ImuTutorial::Signal_Acc& Signal::acc() const {
  const ::ImuTutorial::Signal_Acc* p = acc_;
  // @@protoc_insertion_point(field_get:ImuTutorial.Signal.acc)
  return p != nullptr ? *p : *reinterpret_cast<const ::ImuTutorial::Signal_Acc*>(
      &::ImuTutorial::_Signal_Acc_default_instance_);
}
inline ::ImuTutorial::Signal_Acc* Signal::release_acc() {
  // @@protoc_insertion_point(field_release:ImuTutorial.Signal.acc)
  _has_bits_[0] &= ~0x00000001u;
  ::ImuTutorial::Signal_Acc* temp = acc_;
  acc_ = nullptr;
  return temp;
}
inline ::ImuTutorial::Signal_Acc* Signal::mutable_acc() {
  _has_bits_[0] |= 0x00000001u;
  if (acc_ == nullptr) {
    auto* p = CreateMaybeMessage<::ImuTutorial::Signal_Acc>(GetArenaNoVirtual());
    acc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ImuTutorial.Signal.acc)
  return acc_;
}
inline void Signal::set_allocated_acc(::ImuTutorial::Signal_Acc* acc) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete acc_;
  }
  if (acc) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      acc = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, acc, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  acc_ = acc;
  // @@protoc_insertion_point(field_set_allocated:ImuTutorial.Signal.acc)
}

// required .ImuTutorial.Signal.Angle angle = 7;
inline bool Signal::has_angle() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Signal::clear_angle() {
  if (angle_ != nullptr) angle_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::ImuTutorial::Signal_Angle& Signal::angle() const {
  const ::ImuTutorial::Signal_Angle* p = angle_;
  // @@protoc_insertion_point(field_get:ImuTutorial.Signal.angle)
  return p != nullptr ? *p : *reinterpret_cast<const ::ImuTutorial::Signal_Angle*>(
      &::ImuTutorial::_Signal_Angle_default_instance_);
}
inline ::ImuTutorial::Signal_Angle* Signal::release_angle() {
  // @@protoc_insertion_point(field_release:ImuTutorial.Signal.angle)
  _has_bits_[0] &= ~0x00000002u;
  ::ImuTutorial::Signal_Angle* temp = angle_;
  angle_ = nullptr;
  return temp;
}
inline ::ImuTutorial::Signal_Angle* Signal::mutable_angle() {
  _has_bits_[0] |= 0x00000002u;
  if (angle_ == nullptr) {
    auto* p = CreateMaybeMessage<::ImuTutorial::Signal_Angle>(GetArenaNoVirtual());
    angle_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ImuTutorial.Signal.angle)
  return angle_;
}
inline void Signal::set_allocated_angle(::ImuTutorial::Signal_Angle* angle) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete angle_;
  }
  if (angle) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      angle = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, angle, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  angle_ = angle;
  // @@protoc_insertion_point(field_set_allocated:ImuTutorial.Signal.angle)
}

// required .ImuTutorial.Signal.AngleRate anglerate = 8;
inline bool Signal::has_anglerate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Signal::clear_anglerate() {
  if (anglerate_ != nullptr) anglerate_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::ImuTutorial::Signal_AngleRate& Signal::anglerate() const {
  const ::ImuTutorial::Signal_AngleRate* p = anglerate_;
  // @@protoc_insertion_point(field_get:ImuTutorial.Signal.anglerate)
  return p != nullptr ? *p : *reinterpret_cast<const ::ImuTutorial::Signal_AngleRate*>(
      &::ImuTutorial::_Signal_AngleRate_default_instance_);
}
inline ::ImuTutorial::Signal_AngleRate* Signal::release_anglerate() {
  // @@protoc_insertion_point(field_release:ImuTutorial.Signal.anglerate)
  _has_bits_[0] &= ~0x00000004u;
  ::ImuTutorial::Signal_AngleRate* temp = anglerate_;
  anglerate_ = nullptr;
  return temp;
}
inline ::ImuTutorial::Signal_AngleRate* Signal::mutable_anglerate() {
  _has_bits_[0] |= 0x00000004u;
  if (anglerate_ == nullptr) {
    auto* p = CreateMaybeMessage<::ImuTutorial::Signal_AngleRate>(GetArenaNoVirtual());
    anglerate_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ImuTutorial.Signal.anglerate)
  return anglerate_;
}
inline void Signal::set_allocated_anglerate(::ImuTutorial::Signal_AngleRate* anglerate) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete anglerate_;
  }
  if (anglerate) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      anglerate = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, anglerate, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  anglerate_ = anglerate;
  // @@protoc_insertion_point(field_set_allocated:ImuTutorial.Signal.anglerate)
}

// optional .ImuTutorial.Signal.Quaternion quaternion = 9;
inline bool Signal::has_quaternion() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Signal::clear_quaternion() {
  if (quaternion_ != nullptr) quaternion_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::ImuTutorial::Signal_Quaternion& Signal::quaternion() const {
  const ::ImuTutorial::Signal_Quaternion* p = quaternion_;
  // @@protoc_insertion_point(field_get:ImuTutorial.Signal.quaternion)
  return p != nullptr ? *p : *reinterpret_cast<const ::ImuTutorial::Signal_Quaternion*>(
      &::ImuTutorial::_Signal_Quaternion_default_instance_);
}
inline ::ImuTutorial::Signal_Quaternion* Signal::release_quaternion() {
  // @@protoc_insertion_point(field_release:ImuTutorial.Signal.quaternion)
  _has_bits_[0] &= ~0x00000008u;
  ::ImuTutorial::Signal_Quaternion* temp = quaternion_;
  quaternion_ = nullptr;
  return temp;
}
inline ::ImuTutorial::Signal_Quaternion* Signal::mutable_quaternion() {
  _has_bits_[0] |= 0x00000008u;
  if (quaternion_ == nullptr) {
    auto* p = CreateMaybeMessage<::ImuTutorial::Signal_Quaternion>(GetArenaNoVirtual());
    quaternion_ = p;
  }
  // @@protoc_insertion_point(field_mutable:ImuTutorial.Signal.quaternion)
  return quaternion_;
}
inline void Signal::set_allocated_quaternion(::ImuTutorial::Signal_Quaternion* quaternion) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete quaternion_;
  }
  if (quaternion) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      quaternion = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, quaternion, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  quaternion_ = quaternion;
  // @@protoc_insertion_point(field_set_allocated:ImuTutorial.Signal.quaternion)
}

// -------------------------------------------------------------------

// ImuSignal

// required uint64 time = 1;
inline bool ImuSignal::has_time() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImuSignal::clear_time() {
  time_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint64 ImuSignal::time() const {
  // @@protoc_insertion_point(field_get:ImuTutorial.ImuSignal.time)
  return time_;
}
inline void ImuSignal::set_time(::google::protobuf::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  time_ = value;
  // @@protoc_insertion_point(field_set:ImuTutorial.ImuSignal.time)
}

// repeated .ImuTutorial.Signal signal = 2;
inline int ImuSignal::signal_size() const {
  return signal_.size();
}
inline void ImuSignal::clear_signal() {
  signal_.Clear();
}
inline ::ImuTutorial::Signal* ImuSignal::mutable_signal(int index) {
  // @@protoc_insertion_point(field_mutable:ImuTutorial.ImuSignal.signal)
  return signal_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ImuTutorial::Signal >*
ImuSignal::mutable_signal() {
  // @@protoc_insertion_point(field_mutable_list:ImuTutorial.ImuSignal.signal)
  return &signal_;
}
inline const ::ImuTutorial::Signal& ImuSignal::signal(int index) const {
  // @@protoc_insertion_point(field_get:ImuTutorial.ImuSignal.signal)
  return signal_.Get(index);
}
inline ::ImuTutorial::Signal* ImuSignal::add_signal() {
  // @@protoc_insertion_point(field_add:ImuTutorial.ImuSignal.signal)
  return signal_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ImuTutorial::Signal >&
ImuSignal::signal() const {
  // @@protoc_insertion_point(field_list:ImuTutorial.ImuSignal.signal)
  return signal_;
}

// -------------------------------------------------------------------

// ImuSignalDataset

// repeated .ImuTutorial.ImuSignal imusignal = 1;
inline int ImuSignalDataset::imusignal_size() const {
  return imusignal_.size();
}
inline void ImuSignalDataset::clear_imusignal() {
  imusignal_.Clear();
}
inline ::ImuTutorial::ImuSignal* ImuSignalDataset::mutable_imusignal(int index) {
  // @@protoc_insertion_point(field_mutable:ImuTutorial.ImuSignalDataset.imusignal)
  return imusignal_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::ImuTutorial::ImuSignal >*
ImuSignalDataset::mutable_imusignal() {
  // @@protoc_insertion_point(field_mutable_list:ImuTutorial.ImuSignalDataset.imusignal)
  return &imusignal_;
}
inline const ::ImuTutorial::ImuSignal& ImuSignalDataset::imusignal(int index) const {
  // @@protoc_insertion_point(field_get:ImuTutorial.ImuSignalDataset.imusignal)
  return imusignal_.Get(index);
}
inline ::ImuTutorial::ImuSignal* ImuSignalDataset::add_imusignal() {
  // @@protoc_insertion_point(field_add:ImuTutorial.ImuSignalDataset.imusignal)
  return imusignal_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ImuTutorial::ImuSignal >&
ImuSignalDataset::imusignal() const {
  // @@protoc_insertion_point(field_list:ImuTutorial.ImuSignalDataset.imusignal)
  return imusignal_;
}

// -------------------------------------------------------------------

// Datalength

// required fixed32 length = 1;
inline bool Datalength::has_length() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Datalength::clear_length() {
  length_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::uint32 Datalength::length() const {
  // @@protoc_insertion_point(field_get:ImuTutorial.Datalength.length)
  return length_;
}
inline void Datalength::set_length(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  length_ = value;
  // @@protoc_insertion_point(field_set:ImuTutorial.Datalength.length)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace ImuTutorial

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::ImuTutorial::Signal_Leg> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ImuTutorial::Signal_Leg>() {
  return ::ImuTutorial::Signal_Leg_descriptor();
}
template <> struct is_proto_enum< ::ImuTutorial::Signal_LegPosition> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::ImuTutorial::Signal_LegPosition>() {
  return ::ImuTutorial::Signal_LegPosition_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_ImuEncode_2eproto
